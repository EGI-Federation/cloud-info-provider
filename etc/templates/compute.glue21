##
## GLUE 2.1 template for the compute-related information
##
<%!
  from datetime import datetime
%>
<%
    static_compute_info = attributes['static_compute_info']
    suffix = static_compute_info['suffix']
    endpoints = attributes['endpoints']['endpoints']
    shares = attributes['shares']
    compute_service_id = static_compute_info['compute_service_name'] + '_cloud.compute'
    compute_service_manager = compute_service_id + '_manager'
    timestamp = datetime.now().isoformat()
    validity = 3600
%>\
##
## Cloud Computing Service - GLUE2CloudComputingService
##
dn: GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2Service
objectClass: GLUE2CloudComputingService
GLUE2ServiceID: ${compute_service_id}
GLUE2EntityName: Cloud Compute service on ${static_compute_info['site_name']}
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2ServiceAdminDomainForeignKey: ${static_compute_info['site_name']}
GLUE2ServiceType: IaaS
GLUE2ServiceQualityLevel: ${static_compute_info['compute_service_production_level']}
% for capability in static_compute_info['compute_capabilities']:
GLUE2ServiceCapability: ${capability}
% endfor
# XXX Need to get this info using nova API?
# GLUE2CloudComputingServiceSuspendedVM:
# GLUE2CloudComputingServicePendingVM:
# GLUE2CloudComputingServiceHaltedVM:
# GLUE2CloudComputingServiceTotalVM:
# GLUE2CloudComputingServiceRunningVM:
# TODO find information for this attributes
# GLUE2ServiceComplexity:
# GLUE2ServiceStatusInfo:
# GLUE2CloudComputingServiceAUP:

##
## Computing Manager - GLUE2CloudComputingManager
##
dn: GLUE2ManagerID=${compute_service_manager},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2Manager
objectClass: GLUE2CloudComputingManager
GLUE2ManagerID: ${compute_service_manager}
GLUE2EntityName: Cloud Manager for ${static_compute_info['compute_service_name']}
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2ManagerProductName: ${static_compute_info['compute_hypervisor']}
GLUE2ManagerProductVersion: ${static_compute_info['compute_hypervisor_version']}
GLUE2ManagerServiceForeignKey: ${compute_service_id}
GLUE2CloudComputingManagerCloudComputingServiceForeignKey: ${compute_service_id}
## XXX Disabled for now
##GLUE2CloudComputingManagerTotalCPUs: ${static_compute_info['compute_total_cores']}
##GLUE2CloudComputingManagerTotalRAM: ${static_compute_info['compute_total_ram']}
# TODO find information for this attributes
# GLUE2CloudComputingManagerTotalAccelerators:
# GLUE2CloudComputingManagerInstanceMaxCPU:
# GLUE2CloudComputingManagerInstanceMinCPU:
# GLUE2CloudComputingManagerInstanceMaxAccelerators:
# GLUE2CloudComputingManagerInstanceMinAccelerators:
# GLUE2CloudComputingManagerInstanceMaxRAM:
# GLUE2CloudComputingManagerInstanceMinRAM:
# GLUE2CloudComputingManagerInstanceMaxDedicatedRAM:
# GLUE2CloudComputingManagerInstanceMinDedicatedRAM:
# GLUE2CloudComputingManagerNetworkVirtualizationType:
# GLUE2CloudComputingManagerCPUVirtualizationType:
# GLUE2CloudComputingManagerAcceleratorVirtualizationType:
# GLUE2CloudComputingManagerVirtualdiskFormat:
# GLUE2CloudComputingManagerFailover:
# GLUE2CloudComputingManagerLiveMigration:
# GLUE2CloudComputingManagerVMBackupRestore:

##
## Computing share - GLUE2CloudComputingShare
##
## One share per VO, for all endpoints
## OpenStack: one project per VO
##
% for vo, share in shares.items():
<%
    share_id = ("%s_share_%s_%s" % (compute_service_id, vo, share['project']))
%>\
dn: GLUE2ShareID=${share_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2Share
objectClass: GLUE2CloudComputingShare
GLUE2ShareID: ${share_id}
GLUE2EntityName: Share in service ${compute_service_id} for VO ${vo} (Project ${share['project']})
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2ShareServiceForeignKey: ${compute_service_id}
GLUE2ShareDescription: Share in service ${compute_service_id} for VO ${vo} (Project ${share['project']})
GLUE2CloudComputingShareCloudComputingServiceForeignKey: ${compute_service_id}
# XXX Assuming that all endpoints are in the same share, correct?
% for url, endpoint in endpoints.items():
<%
    endpoint_id =  ("%s_%s_%s_%s" % (endpoint['endpoint_url'],
        endpoint['compute_api_type'], endpoint['compute_api_version'],
        endpoint['compute_api_authn_method']))
%>\
GLUE2ShareEndpointForeignKey: ${endpoint_id}
GLUE2CloudComputingShareCloudComputingEndpointForeignKey: ${endpoint_id}
% endfor
# XXX Should we get this from conf file?
GLUE2CloudComputingShareInstanceMaxCPU: ${share['instance_max_cpu']}
GLUE2CloudComputingShareInstanceMaxRAM: ${share['instance_max_ram']}
GLUE2CloudComputingShareSLA: ${share['sla']}
# TODO find information for this attributes
# GLUE2ShareResourceForeignKey: cream-02.cnaf.infn.it
# GLUE2ComputingShareExecutionEnvironmentForeignKey: cream-02.cnaf.infn.it +++++++++++++++ controllare ++++++++++++++++++
# GLUE2CloudComputingShareInstanceMaxAccelerators:
# XXX Need to get this info using nova API?
# GLUE2CloudComputingShareNetworkInfo:
# GLUE2CloudComputingShareTotalVM:
# GLUE2CloudComputingShareRunningVM:
# GLUE2CloudComputingSharePendingVM:
# GLUE2CloudComputingShareSuspendedVM:
# GLUE2CloudComputingShareHaltedVM:
# GLUE2CloudComputingShareMaxVM:

##
## List of Cloud Computing Endpoints - GLUE2CloudComputingEndpoint
##
## Images and templates are linked to each endpoints
##
## Native endpoints use native image and template IDs
## OCCI endpoints use OCCI-specific images and templates IDs
##
% for url, endpoint in endpoints.items():
<%
    native_endpoint = endpoint['compute_api_type'] == 'OCCI'
    if endpoint['compute_api_type'] == 'OpenStack':
        interface_name = 'org.openstack.nova'
    elif endpoint['compute_api_type'] == 'OpenNebula':
        interface_name = 'org.opennebula.compute'
    else:
        interface_name = 'eu.egi.cloud.vm-management.occi'
    endpoint_id = ("%s_%s_%s_%s" % (endpoint['endpoint_url'],
        endpoint['compute_api_type'], endpoint['compute_api_version'],
        endpoint['compute_api_authn_method']))
    endpoint_name = ("%s (%s/%s) at %s" % (endpoint['compute_api_type'],
        endpoint['compute_api_version'], endpoint['compute_api_authn_method'],
        endpoint['endpoint_url']
        ))
%>\
dn: GLUE2EndpointID=${endpoint_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${endpoint['suffix']}
objectClass: GLUE2Entity
objectClass: GLUE2Endpoint
objectClass: GLUE2CloudComputingEndpoint
GLUE2EndpointID: ${endpoint_id}
# XXX appropriate?
GLUE2EntityName: Cloud Computing Endpoint ${endpoint_name}
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2EndpointURL: ${endpoint['endpoint_url']}
GLUE2EndpointServiceForeignKey: ${compute_service_id}
# XXX Filter cloud.vm.uploadImage from OCCI capabilities?
# XXX should we hide/update the capabilities?
% for capability in endpoint['compute_capabilities']:
GLUE2EndpointCapability: ${capability}
% endfor
GLUE2EndpointQualityLevel: ${endpoint['compute_production_level']}
GLUE2EndpointInterfaceName: ${endpoint['compute_api_type']}
GLUE2EndpointHealthState: ok
GLUE2EndpointServingState: ${endpoint['compute_production_level']}
GLUE2EndpointTechnology: ${endpoint['compute_api_endpoint_technology']}
GLUE2EndpointInterfaceVersion: ${endpoint['compute_api_version']}
GLUE2EndpointImplementor: ${endpoint['compute_middleware_developer']}
GLUE2EndpointImplementationName: ${endpoint['compute_middleware']}
GLUE2EndpointImplementationVersion: ${endpoint['compute_middleware_version']}
GLUE2EndpointDowntimeInfo: See the GOC DB for downtimes: https://goc.egi.eu/gocdbpi/public/?method=get_downtime&ongoing_only=yes&topentity=${static_compute_info['site_name']}
GLUE2EntityOtherInfo: Authn=${endpoint['compute_api_authn_method']}
# TODO find information for this attributes
# GLUE2EndpointSemantics:
# GLUE2EndpointSupportedProfile:
# GLUE2EndpointInterfaceExtension:
# GLUE2EndpointWSDL:
# GLUE2EndpointHealthStateInfo:
# GLUE2EndpointStartTime:
# GLUE2EndpointIssuerCA:
# GLUE2EndpointTrustedCA:
# GLUE2EndpointTrustedCA:
# GLUE2CloudComputingEndpointContextualizationName:
# GLUE2CloudComputingEndpointContextualizationVersion:
## XXX Disabled for now
## GLUE2EndpointDowntimeAnnounce:
## GLUE2EndpointDowntimeStart:
## GLUE2EndpointDowntimeEnd:

##
## List of images
##
% for image_id, image in share['images'].items():
<%
    img_id = image['image_native_id'] if native_endpoint else image_id
    if image['image_description'] is None:
        image['image_description'] = ('%(image_name)s version '
            '%(image_version)s on '
            '%(image_os_family)s %(image_os_name)s '
            '%(image_os_version)s '
            '%(image_platform)s' % image)
%>\
dn: GLUE2CloudComputingImageID=${img_id},GLUE2ShareID=${share_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2CloudComputingImage
GLUE2EntityName: ${image['image_name']}
GLUE2CloudComputingImageID: ${img_id}
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2CloudComputingImageIDForEndpoint: ${img_id}
GLUE2CloudComputingImageMarketPlaceID: ${image['image_marketplace_id']}
GLUE2CloudComputingImageCloudComputingManagerForeignKey: ${compute_service_manager}
# XXX Shouldn't we add a CloudComputingEndpointForeignKey?
GLUE2CloudComputingImageCloudComputingEndpointForeignKey: ${endpoint_id}
GLUE2CloudComputingImageCloudComputingManagerForeignKey: ${compute_service_manager}
GLUE2CloudComputingImageOSName: ${image['image_name']}
GLUE2CloudComputingImageOSVersion: ${image['image_version']}
# XXX appropriate?
GLUE2EntityOtherInfo: ${image['image_description']}
# TODO find information for this attributes
# GLUE2CloudComputingImageOSPlatform:
# GLUE2CloudComputingImageOSFamily:
# GLUE2CloudComputingImageDiskSize:
# GLUE2CloudComputingImageRecommendedCPU:
# GLUE2CloudComputingImageRecommendedAcceleratorType:
# GLUE2CloudComputingImageRecommendedAccelerators:
# GLUE2CloudComputingImageRecommendedRAM:
# GLUE2CloudComputingImageMinCPU:
# GLUE2CloudComputingImageMinAccelerators:
# GLUE2CloudComputingImageMinRAM:
# GLUE2CloudComputingImageAccessInfo:
# GLUE2CloudComputingImageInstalledsoftware:
# XXX To be retrieved from AppDB, cloudkeeper, metadata
GLUE2CloudComputingImageDefaultUserName:
# XXX Skipping dangerous information
## GLUE2CloudComputingImageDefaultPassword:

% endfor
##
## List of templates - GLUE2CloudComputingInstanceType
##
% for template_id, template in share['templates'].items():
<%
    tpl_id = template['template_native_id'] if native_endpoint else template_id
%>
# GLUE2ExecutionEnvironmentCPUVendor: virtual vendor
dn: GLUE2ResourceID=${tpl_id},GLUE2ShareID=${share_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${template['suffix']}
objectClass: GLUE2Entity
objectClass: GLUE2Resource
objectClass: GLUE2CloudComputingInstanceType
GLUE2ResourceID: ${tpl_id}
GLUE2EntityCreationTime: ${timestamp}
GLUE2EntityValidity: ${validity}
GLUE2EntityName: ${tpl_id}
GLUE2CloudComputingInstanceTypeIDForEndpoint: ${tpl_id}
GLUE2ResourceManagerForeignKey: ${compute_service_manager}
GLUE2CloudComputingInstanceTypeCloudComputingManagerForeignKey: ${compute_service_manager}
# XXX Shouldn't we add a CloudComputingEndpointForeignKey?
GLUE2CloudComputingInstanceTypeCloudComputingEndpointForeignKey: ${endpoint_id}
GLUE2CloudComputingInstanceTypePlatform: ${template['template_platform']}
GLUE2CloudComputingInstanceTypevCPU: ${template['template_cpu']}
GLUE2CloudComputingInstanceTypeRAM: ${template['template_memory']}
GLUE2CloudComputingInstanceTypeNetworkIn: TRUE
GLUE2CloudComputingInstanceTypeNetworkOut: TRUE
# TODO find information for this attributes
# GLUE2CloudComputingInstanceTypeMarketPlaceID:
# GLUE2CloudComputingInstanceTypeEphemeralStorage:
# GLUE2CloudComputingInstanceTypeDisk:
# GLUE2CloudComputingInstanceTypeNetworkPortsIn:
# GLUE2CloudComputingInstanceTypeNetworkPortsOut:
# GLUE2CloudComputingInstanceTypeNetworkInfo:
# GLUE2CloudComputingInstanceTypeOtherHardware:

% endfor
% endfor
% endfor
##
## Access Policy - GLUE2AccessPolicy
##
## XXX here we might want to filter endpoints
% for endpoint_url, endpoint in endpoints.items():
<%
    endpoint_id =  ("%s_%s_%s_%s" % (endpoint['endpoint_url'],
        endpoint['compute_api_type'], endpoint['compute_api_version'],
        endpoint['compute_api_authn_method']))
%>\
dn: GLUE2PolicyID=${endpoint_id}_Policy,GLUE2EndpointID=${endpoint_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2Policy
objectClass: GLUE2AccessPolicy
GLUE2PolicyID: ${endpoint_id}_Policy
GLUE2EntityCreationTime: ${timestamp}
GLUE2AccessPolicyEndpointForeignKey: ${endpoint_id}
GLUE2PolicyScheme: org.glite.standard
GLUE2EntityName: Access control rules for Endpoint ${endpoint_id}
% for vo, share in shares.items():
GLUE2PolicyRule: VO:${vo}
% endfor
% for vo, share in shares.items():
GLUE2PolicyUserDomainForeignKey: ${vo}
% endfor
% endfor

##
## Mapping Policy - GLUE2MappingPolicy
##
% for vo, share in shares.items():
<%
    share_id = ("%s_share_%s_%s" % (compute_service_id, vo, share['project']))
%>\
dn: GLUE2PolicyID=${share_id}_Policy,GLUE2ShareID=${share_id},GLUE2ServiceID=${compute_service_id},GLUE2GroupID=resource,${suffix}
objectClass: GLUE2Entity
objectClass: GLUE2Policy
objectClass: GLUE2MappingPolicy
GLUE2PolicyID: ${share_id}_Policy
GLUE2EntityCreationTime: ${timestamp}
GLUE2PolicyScheme: org.glite.standard
GLUE2MappingPolicyShareForeignKey: ${share_id}
% for rule in share['membership']:
GLUE2PolicyRule: ${rule}
% endfor
GLUE2PolicyUserDomainForeignKey: ${vo}
% endfor
## vim:set ft=ldif:
